---
layout: post
title: LC503
---
## [下一个更大的元素iii](https://leetcode-cn.com/problems/next-greater-element-ii/)

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。


### 示例1：
<pre>
<strong>输入:</strong> [1,2,1]
<strong>输出:</strong> [2,-1,2]
<strong>解释:</strong> 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
</pre>

### 思路分析:

单调栈方法：
从右往左开始维护一个单调递增序列，当发现一个当前值比前面的值要小（前面指的是在当前值的右边），开始往右回溯找到最远端仍然大于当前值的数，然后交换，最后将遍历路径反向旋转即可，不包含当前值。

```C++
class Solution {
public:
    int nextGreaterElement(int n) {
        ans = to_string(n);
        reverse(ans.begin(),ans.end());
        int tmp1=-1,tmp2;
        for(int i = 0;i<ans.size();++i){

            while(!stk.empty()&&ans[i]<ans[stk.top()])
            {
                tmp1 = stk.top();
                stk.pop();
            }
            if(tmp1!=-1)
            {
                tmp2 = i;
                break;
            }
            stk.push(i);
        }
         if(tmp1==-1)return tmp1;
        //交换位置
        swap(ans[tmp1],ans[tmp2]);
        reverse(ans.begin(),ans.begin()+tmp2);
        reverse(ans.begin(),ans.end());
        int res = 0;
        for(auto x:ans){
            if(res>INT_MAX/10||(res==INT_MAX/10&&(x-'0')>=8))return -1;
            res = res*10+(x-'0');
        }
        return res;
        
    }
```